{
  "version": 3,
  "sources": ["../src/transmute.ts"],
  "sourcesContent": ["/**\r\n * Dynamically transform a JSON into a Class with private properties and accessor methods at runtime.\r\n * @author: Kapil Kashyap\r\n */\r\n\r\n// CONSTANTS\r\nexport const HASH: string = '#';\r\nexport const CLASSNAME: string = 'Klass';\r\nexport const EMPTY_STRING: string = '';\r\nexport enum ERRORS {\r\n    'INDEX_TYPE' = 'index should be of numeric type',\r\n    'NON_NULL_VALUE' = 'value cannot be undefined',\r\n    'OUT_OF_BOUND' = 'index out of bound exception',\r\n    'JSON_EXPECTED' = 'Expecting a JavaScript Object notation!'\r\n}\r\n\r\n// UTILITY\r\nexport interface IStringIndex extends Record<string, object> {}\r\n\r\nexport type FunctionType = new () => IStringIndex;\r\n\r\nexport const generateFunction = function (name: string): FunctionType {\r\n    // @ts-expect-error we are trying to create a function at runtime\r\n    return new new Function('return function ' + name + '(){}')();\r\n};\r\n\r\nexport const getTypeOfObject = function (o: unknown) {\r\n    const response = Object.prototype.toString.call(o);\r\n    return response\r\n        .substring(1, response.length - 1)\r\n        .split(/\\s/)[1]\r\n        .toLowerCase();\r\n};\r\n\r\nexport const normalize = function (s: string) {\r\n    if (!isNaN(Number(s[0]))) {\r\n        s = '_' + s;\r\n    }\r\n    return s.toString().replace(/\\s|\\./g, EMPTY_STRING);\r\n};\r\n\r\nexport const capitalize = function (s: string) {\r\n    return s[0].toUpperCase() + s.slice(1);\r\n};\r\n\r\nexport const randomNumber = function (fractionDigits = 9, startIndex = 2) {\r\n    return Math.random().toFixed(fractionDigits).substring(startIndex);\r\n};\r\n\r\nexport const jsonStringifyReplacer = function (value: unknown): string | unknown {\r\n    if (typeof value === 'function') {\r\n        return String(value);\r\n    }\r\n    return value;\r\n};\r\n\r\nexport const jsonParseReviver = function (value: unknown): unknown {\r\n    if (typeof value === 'string' && (value.indexOf('function') !== -1 || value.indexOf('=>') !== -1)) {\r\n        return new Function('return ' + value)();\r\n    }\r\n    return value;\r\n};\r\n\r\nexport const memorySizeOf = function (obj: IStringIndex) {\r\n    const formatByteSize = function (bytes: number) {\r\n        const kiloByte = 1024;\r\n        if (bytes < kiloByte) return bytes + ' bytes';\r\n        else if (bytes < Math.pow(kiloByte, 2)) return (bytes / kiloByte).toFixed(6) + ' KiB';\r\n        else if (bytes < Math.pow(kiloByte, 3)) return (bytes / Math.pow(kiloByte, 2)).toFixed(6) + ' MiB';\r\n        else return (bytes / Math.pow(kiloByte, 3)).toFixed(6) + ' GiB';\r\n    };\r\n    const response: string = JSON.stringify(obj, jsonStringifyReplacer);\r\n    return formatByteSize(encodeURI(response).split(/%(?:u[0-9A-F]{2})?[0-9A-F]{2}|./).length - 1);\r\n};\r\n\r\n// TRANSMUTE\r\nexport interface Configuration {\r\n    readOnly: boolean;\r\n    deep: boolean;\r\n}\r\n\r\nexport function transmute(o: IStringIndex, cfg?: Configuration, className?: string): IStringIndex {\r\n    const config: Configuration = {\r\n        readOnly: false,\r\n        deep: true,\r\n        ...cfg\r\n    };\r\n\r\n    // use the passed in class name or generate a random class name\r\n    className = className ?? `${CLASSNAME}${randomNumber()}`;\r\n\r\n    // generate a 'set' accessor method\r\n    const generateSetter = function (fn: FunctionType, prop: string): void {\r\n        fn.prototype['set' + capitalize(normalize(prop))] = function (value: unknown): unknown {\r\n            if (value !== undefined) {\r\n                this[`${HASH}${prop}`] = value;\r\n            }\r\n            return this;\r\n        };\r\n    };\r\n\r\n    // generate a 'get' accessor method\r\n    const generateGetter = function (fn: FunctionType, prop: string): void {\r\n        fn.prototype['get' + capitalize(normalize(prop))] = function (): unknown {\r\n            return this[`${HASH}${prop}`];\r\n        };\r\n    };\r\n\r\n    // generate an indexed 'set' accessor method\r\n    const generateIndexedSetter = function (fn: FunctionType, prop: string): void {\r\n        fn.prototype['set' + capitalize(normalize(prop))] = function (value: unknown, index: number) {\r\n            if (value !== undefined) {\r\n                if (getTypeOfObject(this[`${HASH}${prop}`]) === 'array' && index !== undefined) {\r\n                    if (getTypeOfObject(index) !== 'number') {\r\n                        throw ERRORS.INDEX_TYPE;\r\n                    }\r\n                    if (index >= 0 && index < this[`${HASH}${prop}`].length) {\r\n                        this[`${HASH}${prop}`][index] = value;\r\n                    }\r\n                } else {\r\n                    if (getTypeOfObject(value) !== 'array') {\r\n                        value = [value];\r\n                    }\r\n                    this[`${HASH}${prop}`] = value;\r\n                }\r\n            } else {\r\n                throw ERRORS.NON_NULL_VALUE;\r\n            }\r\n            return this;\r\n        };\r\n    };\r\n\r\n    // generate an indexed 'get' accessor method\r\n    const generateIndexedGetter = function (fn: FunctionType, prop: string): void {\r\n        fn.prototype['get' + capitalize(normalize(prop))] = function (index: number): unknown {\r\n            if (index !== undefined) {\r\n                if (getTypeOfObject(index) !== 'number') {\r\n                    throw ERRORS.INDEX_TYPE;\r\n                }\r\n                if (index < 0 || index > this[`${HASH}${prop}`].length - 1) {\r\n                    throw ERRORS.OUT_OF_BOUND;\r\n                }\r\n                return this[`${HASH}${prop}`][index];\r\n            }\r\n            return [...this[`${HASH}${prop}`]];\r\n        };\r\n    };\r\n\r\n    // generate 'setter' and 'getter' access methods\r\n    const generateAccessorMethods = function (fn: FunctionType, props: string | string[]): void {\r\n        if (typeof props === 'string') {\r\n            props = [props];\r\n        }\r\n        props.forEach((prop) => {\r\n            !config.readOnly && generateSetter(fn, normalize(prop));\r\n            generateGetter(fn, normalize(prop));\r\n        });\r\n    };\r\n\r\n    // generate indexed 'setter' and 'getter' access methods\r\n    const generateIndexedAccessorMethods = function (fn: FunctionType, props: string | string[]): void {\r\n        if (typeof props === 'string') {\r\n            props = [props];\r\n        }\r\n        props.forEach((prop) => {\r\n            !config.readOnly && generateIndexedSetter(fn, normalize(prop));\r\n            generateIndexedGetter(fn, normalize(prop));\r\n        });\r\n    };\r\n\r\n    // attach utility methods to the function prototype\r\n    const generateUtilityMethods = function (fn: FunctionType): void {\r\n        fn.prototype['toJSON'] = function () {\r\n            const jsonObject: IStringIndex = {};\r\n            Object.keys(this).forEach((entry: string): void => {\r\n                if (entry[0] === HASH && typeof this[entry] !== 'function') {\r\n                    const prop: string = entry.substring(1);\r\n                    jsonObject[prop] = this[`get${capitalize(prop)}`]();\r\n                }\r\n            });\r\n            return jsonObject;\r\n        };\r\n    };\r\n\r\n    // check if the input is a JSON object\r\n    if (getTypeOfObject(o) === 'object') {\r\n        const entries: string[] = Object.keys(o);\r\n        const nonArrayKeys = entries.filter((entry) => getTypeOfObject(o[entry]) !== 'array');\r\n        const arrayKeys = entries.filter((entry) => getTypeOfObject(o[entry]) === 'array');\r\n\r\n        // use the class name to create a generator function\r\n        const generatorFn = generateFunction(capitalize(normalize(className)));\r\n        // const instance = new generatorFn();\r\n        const instance: IStringIndex = new generatorFn();\r\n        generateAccessorMethods(generatorFn, nonArrayKeys);\r\n        generateIndexedAccessorMethods(generatorFn, arrayKeys);\r\n        generateUtilityMethods(generatorFn);\r\n\r\n        // convert object properties into private properties, so they cannot be accessed directly\r\n        Object.keys(o).forEach((prop) => (instance[`${HASH}${normalize(prop)}`] = o[prop]));\r\n\r\n        nonArrayKeys.forEach((key: string): void => {\r\n            if (getTypeOfObject(o[key]) === 'object') {\r\n                instance[`${HASH}${normalize(key)}`] = transmute(o[key] as IStringIndex, cfg, capitalize(normalize(key)));\r\n            }\r\n        });\r\n\r\n        // this will recursively transmute if array of object is encountered\r\n        if (config.deep) {\r\n            arrayKeys.forEach((key: string): void => {\r\n                const value = o[key];\r\n                if (Array.isArray(value) && value.length > 0 && getTypeOfObject(value[0]) === 'object') {\r\n                    value.forEach((entry: IStringIndex, index: number): void => {\r\n                        (instance[`${HASH}${normalize(key)}`] as IStringIndex)[index] = transmute(entry, cfg, capitalize(normalize(key)));\r\n                    });\r\n                }\r\n            });\r\n        }\r\n\r\n        return instance;\r\n    } else {\r\n        throw ERRORS.JSON_EXPECTED;\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["HASH", "CLASSNAME", "EMPTY_STRING", "ERRORS", "generateFunction", "name", "getTypeOfObject", "o", "response", "normalize", "s", "capitalize", "randomNumber", "fractionDigits", "startIndex", "jsonStringifyReplacer", "value", "jsonParseReviver", "memorySizeOf", "obj", "formatByteSize", "bytes", "transmute", "cfg", "className", "config", "generateSetter", "fn", "prop", "generateGetter", "generateIndexedSetter", "index", "generateIndexedGetter", "generateAccessorMethods", "props", "generateIndexedAccessorMethods", "generateUtilityMethods", "jsonObject", "entry", "entries", "nonArrayKeys", "arrayKeys", "generatorFn", "instance", "key"]
}
