{
  "version": 3,
  "sources": ["../src/transmute.ts"],
  "sourcesContent": ["/**\n * Dynamically transform a JSON into a Class with private properties and accessor methods at runtime.\n * @author: Kapil Kashyap\n */\n\n// CONSTANTS\nexport const HASH: string = '#';\nexport const CLASSNAME: string = 'Klass';\nexport const EMPTY_STRING: string = '';\nexport enum ERRORS {\n    'INDEX_TYPE' = 'index should be of numeric type',\n    'NON_NULL_VALUE' = 'value cannot be undefined',\n    'OUT_OF_BOUND' = 'index out of bound exception',\n    'JSON_EXPECTED' = 'Expecting a JavaScript Object notation!'\n}\n\n// UTILITY\nexport interface IStringIndex extends Record<string, object> {}\n\nexport type FunctionType = new () => IStringIndex;\n\nexport const generateFunction = function (name: string): FunctionType {\n    // @ts-expect-error we are trying to create a function at runtime\n    return new new Function('return function ' + name + '(){}')();\n};\n\nexport const getTypeOfObject = function (o: unknown) {\n    const response = Object.prototype.toString.call(o);\n    return response\n        .substring(1, response.length - 1)\n        .split(/\\s/)[1]\n        .toLowerCase();\n};\n\nexport const normalize = function (s: string) {\n    if (!isNaN(Number(s[0]))) {\n        s = '_' + s;\n    }\n    return s.toString().replace(/\\s|\\./g, EMPTY_STRING);\n};\n\nexport const capitalize = function (s: string) {\n    return s[0].toUpperCase() + s.slice(1);\n};\n\nexport const randomNumber = function (fractionDigits = 9, startIndex = 2) {\n    return Math.random().toFixed(fractionDigits).substring(startIndex);\n};\n\nexport const jsonStringifyReplacer = function (value: unknown): string | unknown {\n    if (typeof value === 'function') {\n        return String(value);\n    }\n    return value;\n};\n\nexport const jsonParseReviver = function (value: unknown): unknown {\n    if (typeof value === 'string' && (value.indexOf('function') !== -1 || value.indexOf('=>') !== -1)) {\n        return new Function('return ' + value)();\n    }\n    return value;\n};\n\nexport const memorySizeOf = function (obj: IStringIndex) {\n    const formatByteSize = function (bytes: number) {\n        const kiloByte = 1024;\n        if (bytes < kiloByte) return bytes + ' bytes';\n        else if (bytes < Math.pow(kiloByte, 2)) return (bytes / kiloByte).toFixed(6) + ' KiB';\n        else if (bytes < Math.pow(kiloByte, 3)) return (bytes / Math.pow(kiloByte, 2)).toFixed(6) + ' MiB';\n        else return (bytes / Math.pow(kiloByte, 3)).toFixed(6) + ' GiB';\n    };\n    const response: string = JSON.stringify(obj, jsonStringifyReplacer);\n    return formatByteSize(encodeURI(response).split(/%(?:u[0-9A-F]{2})?[0-9A-F]{2}|./).length - 1);\n};\n\n// TRANSMUTE\nexport interface Configuration {\n    readOnly: boolean;\n    deep: boolean;\n}\n\nexport function transmute(o: IStringIndex, cfg?: Configuration, className?: string): IStringIndex {\n    const config: Configuration = {\n        readOnly: false,\n        deep: true,\n        ...cfg\n    };\n\n    // use the passed in class name or generate a random class name\n    className = className ?? `${CLASSNAME}${randomNumber()}`;\n\n    // generate a 'set' accessor method\n    const generateSetter = function (fn: FunctionType, prop: string): void {\n        fn.prototype['set' + capitalize(normalize(prop))] = function (value: unknown): unknown {\n            if (value !== undefined) {\n                this[`${HASH}${prop}`] = value;\n            }\n            return this;\n        };\n    };\n\n    // generate a 'get' accessor method\n    const generateGetter = function (fn: FunctionType, prop: string): void {\n        fn.prototype['get' + capitalize(normalize(prop))] = function (): unknown {\n            return this[`${HASH}${prop}`];\n        };\n    };\n\n    // generate an indexed 'set' accessor method\n    const generateIndexedSetter = function (fn: FunctionType, prop: string): void {\n        fn.prototype['set' + capitalize(normalize(prop))] = function (value: unknown, index: number) {\n            if (value !== undefined) {\n                if (getTypeOfObject(this[`${HASH}${prop}`]) === 'array' && index !== undefined) {\n                    if (getTypeOfObject(index) !== 'number') {\n                        throw ERRORS.INDEX_TYPE;\n                    }\n                    if (index >= 0 && index < this[`${HASH}${prop}`].length) {\n                        this[`${HASH}${prop}`][index] = value;\n                    }\n                } else {\n                    if (getTypeOfObject(value) !== 'array') {\n                        value = [value];\n                    }\n                    this[`${HASH}${prop}`] = value;\n                }\n            } else {\n                throw ERRORS.NON_NULL_VALUE;\n            }\n            return this;\n        };\n    };\n\n    // generate an indexed 'get' accessor method\n    const generateIndexedGetter = function (fn: FunctionType, prop: string): void {\n        fn.prototype['get' + capitalize(normalize(prop))] = function (index: number): unknown {\n            if (index !== undefined) {\n                if (getTypeOfObject(index) !== 'number') {\n                    throw ERRORS.INDEX_TYPE;\n                }\n                if (index < 0 || index > this[`${HASH}${prop}`].length - 1) {\n                    throw ERRORS.OUT_OF_BOUND;\n                }\n                return this[`${HASH}${prop}`][index];\n            }\n            return [...this[`${HASH}${prop}`]];\n        };\n    };\n\n    // generate 'setter' and 'getter' access methods\n    const generateAccessorMethods = function (fn: FunctionType, props: string | string[]): void {\n        if (typeof props === 'string') {\n            props = [props];\n        }\n        props.forEach((prop) => {\n            !config.readOnly && generateSetter(fn, normalize(prop));\n            generateGetter(fn, normalize(prop));\n        });\n    };\n\n    // generate indexed 'setter' and 'getter' access methods\n    const generateIndexedAccessorMethods = function (fn: FunctionType, props: string | string[]): void {\n        if (typeof props === 'string') {\n            props = [props];\n        }\n        props.forEach((prop) => {\n            !config.readOnly && generateIndexedSetter(fn, normalize(prop));\n            generateIndexedGetter(fn, normalize(prop));\n        });\n    };\n\n    // attach utility methods to the function prototype\n    const generateUtilityMethods = function (fn: FunctionType): void {\n        fn.prototype['toJSON'] = function () {\n            const jsonObject: IStringIndex = {};\n            Object.keys(this).forEach((entry: string): void => {\n                if (entry[0] === HASH && typeof this[entry] !== 'function') {\n                    const prop: string = entry.substring(1);\n                    jsonObject[prop] = this[`get${capitalize(prop)}`]();\n                }\n            });\n            return jsonObject;\n        };\n    };\n\n    // check if the input is a JSON object\n    if (getTypeOfObject(o) === 'object') {\n        const entries: string[] = Object.keys(o);\n        const nonArrayKeys = entries.filter((entry) => getTypeOfObject(o[entry]) !== 'array');\n        const arrayKeys = entries.filter((entry) => getTypeOfObject(o[entry]) === 'array');\n\n        // use the class name to create a generator function\n        const generatorFn = generateFunction(capitalize(normalize(className)));\n        // const instance = new generatorFn();\n        const instance: IStringIndex = new generatorFn();\n        generateAccessorMethods(generatorFn, nonArrayKeys);\n        generateIndexedAccessorMethods(generatorFn, arrayKeys);\n        generateUtilityMethods(generatorFn);\n\n        // convert object properties into private properties, so they cannot be accessed directly\n        Object.keys(o).forEach((prop) => (instance[`${HASH}${normalize(prop)}`] = o[prop]));\n\n        nonArrayKeys.forEach((key: string): void => {\n            if (getTypeOfObject(o[key]) === 'object') {\n                instance[`${HASH}${normalize(key)}`] = transmute(o[key] as IStringIndex, cfg, capitalize(normalize(key)));\n            }\n        });\n\n        // this will recursively transmute if array of object is encountered\n        if (config.deep) {\n            arrayKeys.forEach((key: string): void => {\n                const value = o[key];\n                if (Array.isArray(value) && value.length > 0 && getTypeOfObject(value[0]) === 'object') {\n                    value.forEach((entry: IStringIndex, index: number): void => {\n                        (instance[`${HASH}${normalize(key)}`] as IStringIndex)[index] = transmute(entry, cfg, capitalize(normalize(key)));\n                    });\n                }\n            });\n        }\n\n        return instance;\n    } else {\n        throw ERRORS.JSON_EXPECTED;\n    }\n}\n"],
  "mappings": "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",
  "names": ["transmute_exports", "__export", "CLASSNAME", "EMPTY_STRING", "ERRORS", "HASH", "capitalize", "generateFunction", "getTypeOfObject", "jsonParseReviver", "jsonStringifyReplacer", "memorySizeOf", "normalize", "randomNumber", "transmute", "name", "o", "response", "s", "fractionDigits", "startIndex", "value", "obj", "formatByteSize", "bytes", "cfg", "className", "config", "generateSetter", "fn", "prop", "generateGetter", "generateIndexedSetter", "index", "generateIndexedGetter", "generateAccessorMethods", "props", "generateIndexedAccessorMethods", "generateUtilityMethods", "jsonObject", "entry", "entries", "nonArrayKeys", "arrayKeys", "generatorFn", "instance", "key"]
}
